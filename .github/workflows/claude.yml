name: Claude Code (Multi-Agent)

on:
  issues:
    types: [opened]

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write

jobs:
  claude:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      # ============================================================
      # SETUP: Branch detection, checkout, git config
      # ============================================================

      - name: Detect developer branch
        id: dev
        uses: actions/github-script@v7
        with:
          script: |
            let labels = [];
            let issueTitle = '';
            let issueNumber = '';
            if (context.payload.issue) {
              labels = context.payload.issue.labels.map(l => l.name);
              issueTitle = context.payload.issue.title;
              issueNumber = context.payload.issue.number;
            }

            const devLabel = labels.find(l => l.startsWith('developer:'));
            let branch = '';
            let devName = '';
            if (devLabel) {
              devName = devLabel.replace('developer:', '');
              branch = `dev/${devName}`;
            }

            core.setOutput('branch', branch);
            core.setOutput('dev_name', devName);
            core.setOutput('issue_title', issueTitle);
            core.setOutput('issue_number', String(issueNumber));

            // CI option labels (set by bot when creating issue)
            core.setOutput('multi_agent', labels.includes('ci:multi-agent') ? 'true' : 'false');
            core.setOutput('testing', labels.includes('ci:testing') ? 'true' : 'false');
            core.setOutput('approve', labels.includes('ci:approve') ? 'true' : 'false');
            console.log(`CI options: multi_agent=${labels.includes('ci:multi-agent')}, testing=${labels.includes('ci:testing')}, approve=${labels.includes('ci:approve')}`);

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ steps.dev.outputs.branch || 'main' }}

      - name: Configure git
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "claude[bot]"
          git config user.email "claude[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"

      - name: Ensure dev branch exists and is up to date with main
        if: steps.dev.outputs.branch != ''
        run: |
          BRANCH="${{ steps.dev.outputs.branch }}"
          if git ls-remote --heads origin "$BRANCH" | grep -q .; then
            echo "Branch $BRANCH already exists — merging main into it"
            git merge origin/main --no-edit || {
              echo "Merge conflict with main — aborting merge, keeping dev branch as-is"
              git merge --abort 2>/dev/null || true
              echo "Dev branch preserved. CI infra updates from main will be skipped this run."
            }
            git push origin "$BRANCH" || true
          else
            git checkout -b "$BRANCH" origin/main
            git push origin "$BRANCH"
          fi

      - name: Save initial commit SHA
        run: echo "INITIAL_SHA=$(git rev-parse HEAD)" >> "$GITHUB_ENV"

      # ============================================================
      # BRANCH CONTEXT: Persistent memory across CI runs
      # ============================================================

      - name: Load branch context
        run: |
          # Load persistent branch context (previous runs, decisions, preferences)
          # This is the CI equivalent of IDE chat history
          if [ -f ".claude/branch-context.md" ]; then
            echo "Branch context loaded ($(wc -c < .claude/branch-context.md) bytes)"

            # Build formatted section for agent prompts
            {
              echo "BRANCH CONTEXT (previous work on this branch — decisions, patterns, and lessons learned."
              echo "Use this to avoid repeating failed approaches and respect developer preferences):"
              echo ""
              cat .claude/branch-context.md
            } > /tmp/branch-context-section.txt
          else
            echo "" > /tmp/branch-context-section.txt
            echo "No branch context found — first run on this branch"
          fi

      - name: Install Claude Code CLI
        run: |
          curl -fsSL https://claude.ai/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          $HOME/.local/bin/claude --version

      - name: Setup tools
        run: |
          # notify.sh
          if [ -f "./notify.sh" ]; then
            sed -i 's/\r$//' ./notify.sh
            chmod +x ./notify.sh
          fi
          # codex-review.sh
          if [ -f "./codex-review.sh" ]; then
            sed -i 's/\r$//' ./codex-review.sh
            chmod +x ./codex-review.sh
          fi
          # codex-agent.sh (kept for potential future use, but not used in workflow)
          if [ -f "./codex-agent.sh" ]; then
            sed -i 's/\r$//' ./codex-agent.sh
            chmod +x ./codex-agent.sh
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright
        if: steps.dev.outputs.testing == 'true'
        run: npx playwright install chromium

      # ============================================================
      # NOTIFY: Claude started
      # ============================================================

      - name: "Notify: Claude started"
        if: steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"claude_started\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"${{ steps.dev.outputs.issue_title }}\",\"options\":{\"multi_agent\":\"${{ steps.dev.outputs.multi_agent }}\",\"testing\":\"${{ steps.dev.outputs.testing }}\",\"approve\":\"${{ steps.dev.outputs.approve }}\"}}"

      # ============================================================
      # PHASE 1: PLAN (Claude writes a plan)
      # ============================================================

      - name: "Track: Phase 1"
        if: steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"phase\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"phase\":\"Планирование\",\"phase_num\":\"1\",\"silent\":true,\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"\"}"

      - name: "Phase 1: Plan (Opus)"
        id: plan
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          PHASE_NAME: "Планирование"
        run: |
          ISSUE_NUM="${{ github.event.issue.number }}"
          ISSUE_TITLE="${{ steps.dev.outputs.issue_title }}"
          BRANCH=$(git rev-parse --abbrev-ref HEAD)

          cat > /tmp/plan-prompt.txt << 'PROMPT_EOF'
          You are working in a GitHub repository on branch "BRANCH_PLACEHOLDER".

          TASK: Create a detailed implementation plan for Issue #ISSUE_PLACEHOLDER: "TITLE_PLACEHOLDER"

          INSTRUCTIONS:
          1. Read CLAUDE.md for project rules
          2. Examine the codebase to understand the current state
          3. Write a concise implementation plan (10-30 lines) to /tmp/plan.md
          4. The plan should include:
             - What files will be changed/created
             - What specific changes will be made
             - Edge cases to consider
             - Testing approach
          5. Run: ./notify.sh plan "$(cat /tmp/plan.md | head -5)"

          IMPORTANT:
          - DO NOT make any code changes yet
          - DO NOT commit or push anything
          - ONLY write the plan to /tmp/plan.md and notify
          - Stay on the current branch
          PROMPT_EOF

          # Replace placeholders
          sed -i "s|BRANCH_PLACEHOLDER|$BRANCH|g" /tmp/plan-prompt.txt
          sed -i "s|ISSUE_PLACEHOLDER|$ISSUE_NUM|g" /tmp/plan-prompt.txt
          sed -i "s|TITLE_PLACEHOLDER|$ISSUE_TITLE|g" /tmp/plan-prompt.txt

          # Append branch context (persistent memory from previous runs)
          if [ -s /tmp/branch-context-section.txt ]; then
            printf "\n\n" >> /tmp/plan-prompt.txt
            cat /tmp/branch-context-section.txt >> /tmp/plan-prompt.txt
          fi

          echo "=== Phase 1: Planning (Opus) ==="
          claude -p --dangerously-skip-permissions \
            --model claude-opus-4-6 \
            --max-turns 15 \
            --verbose \
            "$(cat /tmp/plan-prompt.txt)" 2>&1 | tee /tmp/phase1-output.txt

          # Verify plan was created
          if [ -f /tmp/plan.md ]; then
            echo "PLAN_CREATED=true" >> "$GITHUB_ENV"
            echo "=== Plan contents ==="
            cat /tmp/plan.md
          else
            echo "PLAN_CREATED=false" >> "$GITHUB_ENV"
            echo "Plan file not created — extracting from output"
            echo "Auto-extracted plan from Claude output" > /tmp/plan.md
            tail -50 /tmp/phase1-output.txt >> /tmp/plan.md
          fi

      - name: "Phase 1: Plan (Codex)"
        id: plan_codex
        if: steps.dev.outputs.codex_impl == 'true'
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          MAX_CODEX_TURNS: "12"
          CODEX_MAX_SESSIONS: "2"
          PHASE_NAME: "Планирование"
        run: |
          ISSUE_NUM="${{ github.event.issue.number }}"
          ISSUE_TITLE="${{ steps.dev.outputs.issue_title }}"
          BRANCH=$(git rev-parse --abbrev-ref HEAD)

          ISSUE_BODY=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/issues/${ISSUE_NUM}" | jq -r '.body // ""')

          cat > /tmp/plan-context.txt << CONTEXT_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          TASK: Create a detailed implementation plan for Issue #${ISSUE_NUM}: "${ISSUE_TITLE}"

          Issue body:
          ${ISSUE_BODY}

          Start by reading CLAUDE.md, then explore the codebase.
          Write the plan to /tmp/plan.md.
          CONTEXT_EOF

          # Append branch context safely (no shell interpolation)
          if [ -s /tmp/branch-context-section.txt ]; then
            printf "\n\n" >> /tmp/plan-context.txt
            cat /tmp/branch-context-section.txt >> /tmp/plan-context.txt
          fi

          echo "=== Phase 1: Planning (Codex) ==="
          ./codex-agent.sh plan /tmp/plan-context.txt 2>&1 | tee /tmp/phase1-output.txt

          if [ -f /tmp/plan.md ]; then
            echo "PLAN_CREATED=true" >> "$GITHUB_ENV"
            echo "=== Plan contents ==="
            cat /tmp/plan.md
          else
            echo "PLAN_CREATED=false" >> "$GITHUB_ENV"
            echo "Plan file not created"
            echo "Auto-extracted plan from Codex output" > /tmp/plan.md
            tail -50 /tmp/phase1-output.txt >> /tmp/plan.md
          fi

      # --- Notify: Plan created ---
      - name: "Notify: Phase 1 — Plan"
        if: env.PLAN_CREATED == 'true' && steps.dev.outputs.approve == 'true'
        continue-on-error: true
        env:
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          PHASE_NAME: "Планирование"
        run: |
          PLAN_TEXT=$(head -20 /tmp/plan.md 2>/dev/null || echo "Plan file not found")
          ./notify.sh plan "Phase 1 — План Claude:\n\n$PLAN_TEXT"

      # ============================================================
      # PHASE 2: CODEX REVIEW (Codex 5.2 reviews the plan)
      # ============================================================

      - name: "Track: Phase 2"
        if: steps.dev.outputs.multi_agent == 'true' && steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"phase\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"phase\":\"Codex ревью\",\"phase_num\":\"2\",\"silent\":true,\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"\"}"

      - name: "Phase 2: Codex plan review"
        id: codex_plan
        if: steps.dev.outputs.multi_agent == 'true'
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
        run: |
          if [ ! -f /tmp/plan.md ]; then
            echo "No plan to review — skipping"
            exit 0
          fi

          echo "=== Phase 2: Codex reviewing plan ==="
          REVIEW=$(./codex-review.sh plan /tmp/plan.md 2>/dev/null || echo "Codex review unavailable")
          echo "$REVIEW" > /tmp/codex-plan-review.txt

          echo "=== Codex review ==="
          echo "$REVIEW"

      # --- Notify: Plan review ---
      - name: "Notify: Phase 2 — Plan review"
        if: steps.dev.outputs.multi_agent == 'true' && steps.dev.outputs.approve == 'true'
        continue-on-error: true
        env:
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          PHASE_NAME: "Ревью плана"
        run: |
          if [ -f /tmp/codex-plan-review.txt ]; then
            REVIEW=$(head -30 /tmp/codex-plan-review.txt)
            ./notify.sh codex_review "Phase 2 — Codex ревью плана:\n\n$REVIEW"
          else
            ./notify.sh info "Phase 2 — Codex ревью пропущено (нет плана)"
          fi

      # ============================================================
      # APPROVAL GATE (optional: wait for developer approval)
      # ============================================================

      - name: "Approval Gate: Request developer approval"
        id: approval_gate
        if: steps.dev.outputs.approve == 'true'
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          PHASE_NAME: "Апрув плана"
        run: |
          BRANCH=$(git rev-parse --abbrev-ref HEAD)
          ISSUE_NUM="${{ github.event.issue.number }}"
          ISSUE_TITLE="${{ steps.dev.outputs.issue_title }}"
          MAX_REVISIONS=3
          REVISION=0

          while [ $REVISION -le $MAX_REVISIONS ]; do
            # Build plan summary for approval
            PLAN_TEXT=""
            if [ -f /tmp/plan.md ]; then
              PLAN_TEXT=$(cat /tmp/plan.md | head -30)
            fi

            CODEX_TEXT=""
            if [ -f /tmp/codex-plan-review.txt ]; then
              CODEX_TEXT=$(head -10 /tmp/codex-plan-review.txt)
            fi

            SUMMARY="${PLAN_TEXT}"
            if [ -n "$CODEX_TEXT" ]; then
              SUMMARY="${SUMMARY}\n\n--- Codex Review ---\n${CODEX_TEXT}"
            fi

            if [ $REVISION -gt 0 ]; then
              SUMMARY="[Ревизия ${REVISION}/${MAX_REVISIONS}]\n\n${SUMMARY}"
            fi

            # Request approval via bot
            JSON_BODY=$(jq -n \
              --arg branch "$DEV_BRANCH" \
              --arg issue_number "$ISSUE_NUMBER" \
              --arg plan_summary "$SUMMARY" \
              '{branch: $branch, issue_number: $issue_number, plan_summary: $plan_summary}')

            curl -s -X POST "$BOT_NOTIFY_URL/ci/request-approval" \
              -H "Content-Type: application/json" \
              -d "$JSON_BODY"

            echo "⏳ Waiting for developer approval (max 15 min)..."

            # Poll for approval every 30 seconds, up to 30 attempts (15 min)
            DECISION=""
            for i in $(seq 1 30); do
              sleep 30
              RESULT=$(curl -s "$BOT_NOTIFY_URL/ci/check-approval?branch=$DEV_BRANCH&issue_number=$ISSUE_NUMBER")
              STATUS=$(echo "$RESULT" | jq -r '.status')

              if [ "$STATUS" = "approved" ]; then
                echo "✅ Plan approved by developer"
                echo "PLAN_APPROVED=true" >> "$GITHUB_ENV"
                exit 0
              elif [ "$STATUS" = "rejected" ]; then
                echo "❌ Plan rejected by developer"
                echo "PLAN_APPROVED=false" >> "$GITHUB_ENV"
                ./notify.sh error "План отклонён разработчиком. CI остановлен."
                exit 1
              elif [ "$STATUS" = "revision" ]; then
                FEEDBACK=$(echo "$RESULT" | jq -r '.feedback // ""')
                echo "✏️ Developer requested revision: $FEEDBACK"
                DECISION="revision"
                break
              fi
              echo "⏳ Waiting... ($i/30)"
            done

            if [ "$DECISION" != "revision" ]; then
              echo "⏰ Approval timeout (15 min) — stopping CI"
              echo "PLAN_APPROVED=false" >> "$GITHUB_ENV"
              ./notify.sh error "Таймаут ожидания апрува плана (15 мин). CI остановлен."
              exit 1
            fi

            # --- Revision: Claude re-plans with feedback ---
            REVISION=$((REVISION + 1))
            if [ $REVISION -gt $MAX_REVISIONS ]; then
              echo "Max revisions reached ($MAX_REVISIONS)"
              echo "PLAN_APPROVED=false" >> "$GITHUB_ENV"
              ./notify.sh error "Превышен лимит ревизий плана ($MAX_REVISIONS). CI остановлен."
              exit 1
            fi

            echo "=== Revision $REVISION: Re-planning with feedback ==="

            CURRENT_PLAN=$(cat /tmp/plan.md 2>/dev/null || echo "")

            cat > /tmp/revise-prompt.txt << REVISE_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          TASK: Revise the implementation plan for Issue #${ISSUE_NUM}: "${ISSUE_TITLE}"

          YOUR PREVIOUS PLAN:
          ${CURRENT_PLAN}

          DEVELOPER FEEDBACK (address these concerns):
          ${FEEDBACK}

          INSTRUCTIONS:
          1. Read the developer's feedback carefully
          2. Revise your plan in /tmp/plan.md addressing their concerns
          3. Run: ./notify.sh progress "Revised plan based on feedback"
          4. DO NOT implement anything — only update the plan
          5. Stay on the current branch
          REVISE_EOF

            # Append branch context safely (no shell interpolation)
            if [ -s /tmp/branch-context-section.txt ]; then
              printf "\n\n" >> /tmp/revise-prompt.txt
              cat /tmp/branch-context-section.txt >> /tmp/revise-prompt.txt
            fi

            claude -p --dangerously-skip-permissions \
              --model claude-opus-4-6 \
              --max-turns 10 \
              --verbose \
              "$(cat /tmp/revise-prompt.txt)" 2>&1 | tee /tmp/revision-output.txt

            echo "Plan revised, requesting approval again..."
          done

      # ============================================================
      # PHASE 3: IMPLEMENT (Claude implements with plan + review)
      # ============================================================

      - name: "Track: Phase 3"
        if: steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"phase\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"phase\":\"Реализация\",\"phase_num\":\"3\",\"silent\":true,\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"\"}"

      - name: "Phase 3: Implement (Opus)"
        id: implement
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          PHASE_NAME: "Реализация"
        run: |
          ISSUE_NUM="${{ github.event.issue.number }}"
          ISSUE_TITLE="${{ steps.dev.outputs.issue_title }}"
          BRANCH=$(git rev-parse --abbrev-ref HEAD)

          PLAN=""
          if [ -f /tmp/plan.md ]; then
            PLAN=$(cat /tmp/plan.md)
          fi

          REVIEW=""
          if [ -f /tmp/codex-plan-review.txt ]; then
            REVIEW=$(cat /tmp/codex-plan-review.txt)
          fi

          cat > /tmp/implement-prompt.txt << PROMPT_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          TASK: Implement changes for Issue #${ISSUE_NUM}: "${ISSUE_TITLE}"

          YOUR PLAN (from Phase 1):
          ${PLAN}

          REVIEWER FEEDBACK (address any concerns):
          ${REVIEW}

          WORKFLOW:
          1. Read CLAUDE.md for project rules
          2. Implement the changes according to the plan
          3. Address the reviewer's feedback
          4. ./notify.sh progress "Brief description of what was done"
          5. git add -A && git commit -m "feat: ${ISSUE_TITLE} (#${ISSUE_NUM})"
          6. git push origin ${BRANCH}
          7. Write lessons learned to /tmp/agent-lessons.md (see TRANSCRIPT below)

          TRANSCRIPT & LESSONS (mandatory — write to /tmp/agent-lessons.md before finishing):
          After pushing your code, create /tmp/agent-lessons.md with:
          - **Decisions**: key choices you made and WHY (e.g. "Used X instead of Y because Z")
          - **Failed approaches**: what you tried that didn't work and why (e.g. "Tried patching foo.ts but import cycle prevented it")
          - **Errors fixed**: build/test errors you encountered and how you fixed them
          - **Developer preferences**: any patterns or conventions you noticed the developer prefers
          - **Warnings for next run**: things the next agent should know (e.g. "Don't touch file X, it has circular deps")
          Keep it concise but specific (5-15 lines). This file persists across CI runs as branch memory.

          RULES:
          - Stay on branch ${BRANCH}
          - Make clean, focused changes
          - Follow project conventions from CLAUDE.md
          - Once pushed, STOP — do not loop
          PROMPT_EOF

          # Append branch context safely (no shell interpolation of context content)
          if [ -s /tmp/branch-context-section.txt ]; then
            printf "\n\n" >> /tmp/implement-prompt.txt
            cat /tmp/branch-context-section.txt >> /tmp/implement-prompt.txt
          fi

          echo "=== Phase 3: Implementing (Opus) ==="
          set +e
          claude -p --dangerously-skip-permissions \
            --model claude-opus-4-6 \
            --max-turns 50 \
            --verbose \
            "$(cat /tmp/implement-prompt.txt)" 2>&1 | tee /tmp/phase3-output.txt
          EXIT_CODE=${PIPESTATUS[0]}

          if grep -qi "Reached max turns\|max.turns" /tmp/phase3-output.txt; then
            echo "IMPL_MAX_TURNS=true" >> "$GITHUB_ENV"
            exit 1
          fi
          exit $EXIT_CODE

      # Continue Opus implementation if hit max turns
      - name: "Phase 3: Implement continue (+30)"
        id: impl_cont
        if: steps.implement.outcome == 'failure' && env.IMPL_MAX_TURNS == 'true'
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          PHASE_NAME: "Реализация"
        run: |
          echo "=== Phase 3: Continuing implementation (+30 turns) ==="
          claude -p --dangerously-skip-permissions \
            --model claude-opus-4-6 \
            --continue \
            --max-turns 30 \
            --verbose

      - name: "Phase 3: Implement (Codex)"
        id: implement_codex
        if: steps.dev.outputs.codex_impl == 'true'
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          MAX_CODEX_TURNS: "12"
          CODEX_MAX_SESSIONS: "3"
          CODEX_PROFILE: ${{ steps.profile.outputs.profile || 'small' }}
          PHASE_NAME: "Реализация"
        run: |
          ISSUE_NUM="${{ github.event.issue.number }}"
          ISSUE_TITLE="${{ steps.dev.outputs.issue_title }}"
          BRANCH=$(git rev-parse --abbrev-ref HEAD)

          PLAN=""
          if [ -f /tmp/plan.md ]; then
            PLAN=$(cat /tmp/plan.md)
          fi

          REVIEW=""
          if [ -f /tmp/codex-plan-review.txt ]; then
            REVIEW=$(cat /tmp/codex-plan-review.txt)
          fi

          cat > /tmp/impl-context.txt << CONTEXT_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          TASK: Implement changes for Issue #${ISSUE_NUM}: "${ISSUE_TITLE}"

          YOUR PLAN (from Phase 1):
          ${PLAN}

          REVIEWER FEEDBACK (address any concerns):
          ${REVIEW}

          After implementing:
          1. git add -A && git commit -m "feat: ${ISSUE_TITLE} (#${ISSUE_NUM})"
          2. git push origin ${BRANCH}
          3. Write lessons to /tmp/agent-lessons.md (decisions made, failed approaches, errors fixed, warnings for next run — 5-15 lines)
          4. Call done()

          Stay on branch ${BRANCH}. Follow project conventions from CLAUDE.md.
          CONTEXT_EOF

          # Append branch context safely (no shell interpolation of context content)
          if [ -s /tmp/branch-context-section.txt ]; then
            printf "\n\n" >> /tmp/impl-context.txt
            cat /tmp/branch-context-section.txt >> /tmp/impl-context.txt
          fi

          echo "=== Phase 3: Implementing (Codex) ==="
          ./codex-agent.sh implement /tmp/impl-context.txt 2>&1 | tee /tmp/phase3-output.txt

      # --- Notify: Phase 3 result ---
      - name: "Notify: Phase 3 — Implementation"
        if: steps.dev.outputs.approve == 'true'
        continue-on-error: true
        env:
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          PHASE_NAME: "Реализация"
        run: |
          CURRENT_SHA=$(git rev-parse HEAD)
          if [ "$CURRENT_SHA" != "$INITIAL_SHA" ]; then
            CHANGES=$(git log --oneline "$INITIAL_SHA"..HEAD | head -5)
            FILES=$(git diff --name-only "$INITIAL_SHA"..HEAD | head -10)
            ./notify.sh progress "Phase 3 — Claude реализовал:\n\nКоммиты:\n$CHANGES\n\nФайлы:\n$FILES"
          else
            ./notify.sh error "Phase 3 — Claude не создал коммитов"
          fi

      # ============================================================
      # PHASE 4: CODE REVIEW (Codex reviews the diff)
      # ============================================================

      - name: "Track: Phase 4"
        if: steps.dev.outputs.multi_agent == 'true' && steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"phase\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"phase\":\"Codex код ревью\",\"phase_num\":\"4\",\"silent\":true,\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"\"}"

      - name: "Phase 4: Codex code review"
        id: codex_code
        if: steps.dev.outputs.multi_agent == 'true'
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
        run: |
          CURRENT_SHA=$(git rev-parse HEAD)
          if [ "$CURRENT_SHA" = "$INITIAL_SHA" ]; then
            echo "No changes to review — skipping"
            echo "CODE_REVIEW_OK=true" >> "$GITHUB_ENV"
            exit 0
          fi

          echo "=== Phase 4: Codex reviewing code ==="
          git diff "$INITIAL_SHA"..HEAD > /tmp/changes.diff

          REVIEW=$(./codex-review.sh code /tmp/changes.diff 2>/dev/null || echo "Codex review unavailable")
          echo "$REVIEW" > /tmp/codex-code-review.txt

          echo "=== Codex code review ==="
          echo "$REVIEW"

          if echo "$REVIEW" | grep -qi "выглядит хорошо\|looks good\|no issues"; then
            echo "CODE_REVIEW_OK=true" >> "$GITHUB_ENV"
          else
            echo "CODE_REVIEW_OK=false" >> "$GITHUB_ENV"
          fi

      # --- Notify: Code review ---
      - name: "Notify: Phase 4 — Code review"
        if: steps.dev.outputs.multi_agent == 'true' && steps.dev.outputs.approve == 'true'
        continue-on-error: true
        env:
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          PHASE_NAME: "Код ревью"
        run: |
          if [ -f /tmp/codex-code-review.txt ]; then
            REVIEW=$(head -30 /tmp/codex-code-review.txt)
            if [ "$CODE_REVIEW_OK" = "true" ]; then
              ./notify.sh codex_review "Phase 4 — Codex: код ОК\n\n$REVIEW"
            else
              ./notify.sh codex_review "Phase 4 — Codex нашёл замечания:\n\n$REVIEW"
            fi
          else
            ./notify.sh info "Phase 4 — Codex ревью пропущено (нет изменений)"
          fi

      # Fix issues found by code review (one pass)
      - name: "Phase 4: Fix review issues"
        id: fix_review
        if: steps.dev.outputs.multi_agent == 'true' && env.CODE_REVIEW_OK == 'false'
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          PHASE_NAME: "Исправления"
        run: |
          BRANCH=$(git rev-parse --abbrev-ref HEAD)
          ISSUE_NUM="${{ github.event.issue.number }}"

          REVIEW=""
          if [ -f /tmp/codex-code-review.txt ]; then
            REVIEW=$(cat /tmp/codex-code-review.txt)
          fi

          cat > /tmp/fix-prompt.txt << PROMPT_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          A code reviewer found issues with your implementation for Issue #${ISSUE_NUM}.

          REVIEW FEEDBACK:
          ${REVIEW}

          INSTRUCTIONS:
          1. Fix the issues mentioned in the review
          2. Do NOT break existing functionality
          3. git add -A && git commit -m "fix: address code review feedback (#${ISSUE_NUM})"
          4. git push origin ${BRANCH}
          5. Once pushed, STOP
          PROMPT_EOF

          echo "=== Phase 4: Fixing review issues (Opus) ==="
          claude -p --dangerously-skip-permissions \
            --model claude-opus-4-6 \
            --max-turns 20 \
            --verbose \
            "$(cat /tmp/fix-prompt.txt)" 2>&1 | tee /tmp/fix-review-output.txt

      # Fix issues found by code review (one pass) — Codex fixes
      - name: "Phase 4: Fix review issues (Codex)"
        id: fix_review_codex
        if: steps.dev.outputs.multi_agent == 'true' && env.CODE_REVIEW_OK == 'false' && steps.dev.outputs.codex_impl == 'true'
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          MAX_CODEX_TURNS: "12"
          CODEX_MAX_SESSIONS: "2"
          CODEX_PROFILE: ${{ steps.profile.outputs.profile || 'small' }}
          PHASE_NAME: "Исправления"
        run: |
          BRANCH=$(git rev-parse --abbrev-ref HEAD)
          ISSUE_NUM="${{ github.event.issue.number }}"

          REVIEW=""
          if [ -f /tmp/codex-code-review.txt ]; then
            REVIEW=$(cat /tmp/codex-code-review.txt)
          fi

          cat > /tmp/fix-context.txt << CONTEXT_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          A code reviewer (Opus) found issues with your implementation for Issue #${ISSUE_NUM}.

          REVIEW FEEDBACK:
          ${REVIEW}

          Fix the issues, then:
          1. git add -A && git commit -m "fix: address code review feedback (#${ISSUE_NUM})"
          2. git push origin ${BRANCH}
          3. Call done()
          CONTEXT_EOF

          echo "=== Phase 4: Fixing review issues (Codex) ==="
          ./codex-agent.sh implement /tmp/fix-context.txt 2>&1 | tee /tmp/fix-review-output.txt

      # --- Notify: Phase 4 fix result ---
      - name: "Notify: Phase 4 — Fix applied"
        if: steps.dev.outputs.multi_agent == 'true' && env.CODE_REVIEW_OK == 'false' && steps.dev.outputs.approve == 'true'
        continue-on-error: true
        env:
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          PHASE_NAME: "Исправления"
        run: |
          if [ "${{ steps.fix_review.outcome }}" = "success" ]; then
            ./notify.sh progress "Phase 4 — Claude исправил замечания Codex"
          else
            ./notify.sh error "Phase 4 — Claude не смог исправить замечания"
          fi

      # ============================================================
      # PHASE 5: SMOKE TESTS + PERFORMANCE
      # ============================================================

      - name: "Track: Phase 5"
        if: steps.dev.outputs.testing == 'true' && steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"phase\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"phase\":\"Тестирование\",\"phase_num\":\"5\",\"silent\":true,\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"\"}"

      - name: "Phase 5a: Run smoke tests"
        id: e2e_smoke
        if: steps.dev.outputs.testing == 'true'
        continue-on-error: true
        env:
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          PHASE_NAME: "Тесты"
        run: |
          CURRENT_SHA=$(git rev-parse HEAD)
          if [ "$CURRENT_SHA" = "$INITIAL_SHA" ]; then
            echo "No changes — skipping tests"
            echo "SMOKE_OK=skip" >> "$GITHUB_ENV"
            exit 0
          fi

          echo "=== Phase 5a: Smoke tests ==="
          npx playwright test smoke 2>&1 | tee /tmp/smoke-output.txt
          EXIT_CODE=${PIPESTATUS[0]}

          if [ $EXIT_CODE -eq 0 ]; then
            echo "SMOKE_OK=true" >> "$GITHUB_ENV"
            [ -f "./notify.sh" ] && ./notify.sh test_pass "Smoke тесты пройдены"
          else
            echo "SMOKE_OK=false" >> "$GITHUB_ENV"
            FAILURES=$(grep -E "FAIL|Error|✘" /tmp/smoke-output.txt | head -5)
            [ -f "./notify.sh" ] && ./notify.sh test_fail "Smoke тесты упали: $FAILURES"
          fi
          exit 0

      - name: "Phase 5b: Run performance tests"
        id: e2e_perf
        if: steps.dev.outputs.testing == 'true'
        continue-on-error: true
        env:
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          PHASE_NAME: "Тесты"
        run: |
          CURRENT_SHA=$(git rev-parse HEAD)
          if [ "$CURRENT_SHA" = "$INITIAL_SHA" ]; then
            echo "PERF_OK=skip" >> "$GITHUB_ENV"
            exit 0
          fi

          echo "=== Phase 5b: Performance benchmarks ==="
          npx playwright test performance 2>&1 | tee /tmp/perf-output.txt
          EXIT_CODE=${PIPESTATUS[0]}

          if [ $EXIT_CODE -eq 0 ]; then
            echo "PERF_OK=true" >> "$GITHUB_ENV"
            [ -f "./notify.sh" ] && ./notify.sh perf_pass "Все бенчмарки в бюджете"
          else
            echo "PERF_OK=false" >> "$GITHUB_ENV"
            FAILURES=$(grep -E "exceeds|below|grew" /tmp/perf-output.txt | head -5)
            [ -f "./notify.sh" ] && ./notify.sh perf_fail "Перфоманс регрессия: $FAILURES"
          fi
          exit 0

      # Auto-fix smoke failures
      - name: "Phase 5: Fix smoke test failures"
        id: fix_smoke
        if: steps.dev.outputs.testing == 'true' && env.SMOKE_OK == 'false'
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          PHASE_NAME: "Тесты"
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
        run: |
          BRANCH=$(git rev-parse --abbrev-ref HEAD)
          ISSUE_NUM="${{ github.event.issue.number }}"
          TEST_OUTPUT=$(cat /tmp/smoke-output.txt | tail -50)

          cat > /tmp/fix-smoke-prompt.txt << PROMPT_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          Playwright smoke tests FAILED after your implementation for Issue #${ISSUE_NUM}.

          TEST OUTPUT:
          ${TEST_OUTPUT}

          INSTRUCTIONS:
          1. Read the test failures carefully
          2. Fix the application code (NOT the tests) to make them pass
          3. Run: npx playwright test smoke — to verify fixes
          4. git add -A && git commit -m "fix: resolve smoke test failures (#${ISSUE_NUM})"
          5. git push origin ${BRANCH}
          6. Once pushed, STOP

          IMPORTANT: Fix the application code, not the test expectations.
          Only fix tests if they have genuine bugs (wrong selectors, etc.)
          PROMPT_EOF

          echo "=== Phase 5: Fixing smoke test failures ==="
          claude -p --dangerously-skip-permissions \
            --model claude-opus-4-6 \
            --max-turns 20 \
            --verbose \
            "$(cat /tmp/fix-smoke-prompt.txt)"

      # Auto-fix performance regressions
      - name: "Phase 5: Fix performance regressions"
        id: fix_perf
        if: steps.dev.outputs.testing == 'true' && env.PERF_OK == 'false'
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          PHASE_NAME: "Тесты"
        run: |
          BRANCH=$(git rev-parse --abbrev-ref HEAD)
          ISSUE_NUM="${{ github.event.issue.number }}"
          PERF_OUTPUT=$(cat /tmp/perf-output.txt | tail -60)

          cat > /tmp/fix-perf-prompt.txt << PROMPT_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          Performance benchmarks FAILED after your implementation for Issue #${ISSUE_NUM}.
          Your changes caused a performance regression.

          FAILED BENCHMARKS:
          ${PERF_OUTPUT}

          PERFORMANCE BUDGETS (see tests/e2e/performance.spec.ts):
          - Page load (DOMContentLoaded): < 2s
          - Total page weight: < 500 KB
          - JS heap: < 30 MB (after 2s gameplay)
          - CLS: < 0.1
          - Input response: < 500ms
          - FPS: > 30 during gameplay
          - Memory leak: < 5 MB growth over 10s

          INSTRUCTIONS:
          1. Identify which performance budget was exceeded
          2. Optimize the code to fix the regression:
             - Reduce file sizes (minify, remove unused code/assets)
             - Fix memory leaks (clean up event listeners, timers, closures)
             - Reduce layout thrashing (batch DOM reads/writes)
             - Optimize canvas rendering (reduce draw calls, cache)
             - Remove unnecessary network requests
          3. Run: npx playwright test performance — to verify fixes
          4. git add -A && git commit -m "perf: fix performance regression (#${ISSUE_NUM})"
          5. git push origin ${BRANCH}
          6. Once pushed, STOP

          IMPORTANT: Optimize the code, do NOT relax the budget thresholds.
          PROMPT_EOF

          echo "=== Phase 5: Fixing performance regressions ==="
          claude -p --dangerously-skip-permissions \
            --model claude-opus-4-6 \
            --max-turns 25 \
            --verbose \
            "$(cat /tmp/fix-perf-prompt.txt)"

      # ============================================================
      # SONNET FALLBACK (if Opus attempts failed)
      # ============================================================

      - name: Check if implementation succeeded
        if: always()
        id: opus_result
        run: |
          CURRENT_SHA=$(git rev-parse HEAD)
          if [ "$CURRENT_SHA" != "$INITIAL_SHA" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Reset for Sonnet
        if: steps.opus_result.outputs.ok == 'false'
        run: |
          git checkout -- . 2>/dev/null || true
          git clean -fd 2>/dev/null || true

      - name: "Notify: switching to Sonnet"
        if: steps.opus_result.outputs.ok == 'false' && steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"opus_unavailable\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"${{ steps.dev.outputs.issue_title }}\"}"

      - name: "Claude Code — Sonnet (fallback)"
        id: sonnet
        if: steps.opus_result.outputs.ok == 'false'
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
          PHASE_NAME: "Sonnet fallback"
        run: |
          ISSUE_NUM="${{ github.event.issue.number }}"
          ISSUE_TITLE="${{ steps.dev.outputs.issue_title }}"
          BRANCH=$(git rev-parse --abbrev-ref HEAD)

          cat > /tmp/sonnet-prompt.txt << PROMPT_EOF
          You are working in a GitHub repository on branch "${BRANCH}".

          TASK: Implement changes for Issue #${ISSUE_NUM}: "${ISSUE_TITLE}"

          WORKFLOW:
          1. ./notify.sh plan "Your plan"
          2. Read CLAUDE.md for project rules
          3. Implement changes
          4. git add -A && git commit -m "feat: ${ISSUE_TITLE} (#${ISSUE_NUM})"
          5. git push origin ${BRANCH}
          6. Write lessons to /tmp/agent-lessons.md (decisions, failed approaches, errors, warnings — 5-15 lines)

          RULES:
          - Stay on branch ${BRANCH}
          - Make clean, focused changes
          - Once pushed, STOP
          PROMPT_EOF

          # Append branch context safely (no shell interpolation of context content)
          if [ -s /tmp/branch-context-section.txt ]; then
            printf "\n\n" >> /tmp/sonnet-prompt.txt
            cat /tmp/branch-context-section.txt >> /tmp/sonnet-prompt.txt
          fi

          set +e
          claude -p --dangerously-skip-permissions \
            --model claude-sonnet-4-5-20250929 \
            --max-turns 50 \
            --verbose \
            "$(cat /tmp/sonnet-prompt.txt)" 2>&1 | tee /tmp/sonnet-output.txt
          EXIT_CODE=${PIPESTATUS[0]}

          if grep -qi "Reached max turns\|max.turns" /tmp/sonnet-output.txt; then
            echo "SONNET_MAX_TURNS=true" >> "$GITHUB_ENV"
            exit 1
          fi
          exit $EXIT_CODE

      - name: "Claude Code — Sonnet continue (+30)"
        if: steps.sonnet.outcome == 'failure' && env.SONNET_MAX_TURNS == 'true'
        continue-on-error: true
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
        run: |
          claude -p --dangerously-skip-permissions \
            --model claude-sonnet-4-5-20250929 \
            --continue \
            --max-turns 30 \
            --verbose

      # ============================================================
      # VERIFY & FINALIZE
      # ============================================================

      - name: "Track: Финализация"
        if: always() && steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"phase\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"phase\":\"Финализация\",\"phase_num\":\"6\",\"silent\":true,\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"\"}"

      - name: Verify actual push
        if: always()
        id: verify
        run: |
          CURRENT_SHA=$(git rev-parse HEAD)
          echo "Initial SHA: $INITIAL_SHA"
          echo "Current SHA: $CURRENT_SHA"

          if [[ "$CURRENT_SHA" != "$INITIAL_SHA" ]]; then
            echo "New local commits detected"
            git log --oneline "$INITIAL_SHA"..HEAD
            echo "pushed=true" >> "$GITHUB_OUTPUT"
            echo "commit_sha=$CURRENT_SHA" >> "$GITHUB_OUTPUT"
            echo "commit_sha_short=$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"
          else
            git fetch origin
            BRANCH=$(git rev-parse --abbrev-ref HEAD)
            REMOTE_SHA=$(git rev-parse "origin/$BRANCH" 2>/dev/null || echo "none")
            if [[ "$REMOTE_SHA" != "$INITIAL_SHA" ]] && [[ "$REMOTE_SHA" != "none" ]]; then
              echo "Remote has new commits"
              echo "pushed=true" >> "$GITHUB_OUTPUT"
              echo "commit_sha=$REMOTE_SHA" >> "$GITHUB_OUTPUT"
              echo "commit_sha_short=$(git rev-parse --short $REMOTE_SHA)" >> "$GITHUB_OUTPUT"
            else
              echo "No new commits"
              echo "pushed=false" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: Update DEVLOG.md
        if: always() && steps.verify.outputs.pushed == 'true'
        continue-on-error: true
        run: |
          BRANCH=$(git rev-parse --abbrev-ref HEAD)
          COMMIT_SHA="${{ steps.verify.outputs.commit_sha }}"
          COMMIT_SHORT="${{ steps.verify.outputs.commit_sha_short }}"
          ISSUE_NUM="${{ steps.dev.outputs.issue_number }}"
          ISSUE_TITLE="${{ steps.dev.outputs.issue_title }}"
          TODAY=$(date +%Y-%m-%d)

          CHANGED_FILES=$(git diff --name-only "$INITIAL_SHA".."$COMMIT_SHA" 2>/dev/null | grep -v "DEVLOG.md" || echo "")

          FILES_LIST=""
          while IFS= read -r file; do
            [ -n "$file" ] && FILES_LIST="${FILES_LIST}- \`${file}\`
          "
          done <<< "$CHANGED_FILES"

          if [ ! -f "DEVLOG.md" ]; then
            printf "# Development Log\n\nИстория изменений для cherry-pick в main.\n\n" > DEVLOG.md
          fi

          ENTRY="## #${ISSUE_NUM} — ${ISSUE_TITLE}
          **Дата:** ${TODAY}
          **Ветка:** ${BRANCH}
          **Коммит:** \`${COMMIT_SHORT}\`
          **Статус:** ✅ готово к переносу

          ### Изменённые файлы
          ${FILES_LIST}
          ### Как перенести в main
          \`\`\`bash
          git cherry-pick ${COMMIT_SHA}
          \`\`\`

          ---

          "

          head -4 DEVLOG.md > DEVLOG_new.md
          echo "$ENTRY" >> DEVLOG_new.md
          tail -n +5 DEVLOG.md >> DEVLOG_new.md
          mv DEVLOG_new.md DEVLOG.md

          git add DEVLOG.md
          git commit -m "docs: update DEVLOG for #${ISSUE_NUM}" || true
          git push origin "$BRANCH" || true

      # ============================================================
      # UPDATE BRANCH CONTEXT (persistent memory for next run)
      # ============================================================

      - name: Update branch context
        if: always() && steps.verify.outputs.pushed == 'true'
        continue-on-error: true
        run: |
          BRANCH=$(git rev-parse --abbrev-ref HEAD)
          ISSUE_NUM="${{ steps.dev.outputs.issue_number }}"
          ISSUE_TITLE="${{ steps.dev.outputs.issue_title }}"
          TODAY=$(date +%Y-%m-%d)
          COMMIT_SHORT="${{ steps.verify.outputs.commit_sha_short }}"

          mkdir -p .claude

          # Initialize file if it doesn't exist
          if [ ! -f .claude/branch-context.md ]; then
            {
              echo "# Branch Context: ${BRANCH}"
              echo ""
              echo "Persistent memory across CI runs — the CI equivalent of IDE chat history."
              echo "Contains: full plans, review feedback, errors, failed approaches, lessons learned."
              echo "Read by agent at start of each run to avoid repeating mistakes."
              echo ""
            } > .claude/branch-context.md
          fi

          # --- Gather rich data for the entry ---

          CHANGED_FILES=$(git diff --name-only "$INITIAL_SHA".."$(git rev-parse HEAD)" 2>/dev/null \
            | grep -v 'branch-context\|DEVLOG' | head -20 | tr '\n' ', ' | sed 's/,$//')

          # Full plan (up to 8KB — this is the most valuable context for future runs)
          PLAN_TEXT=""
          if [ -f /tmp/plan.md ]; then
            PLAN_TEXT=$(head -c 8000 /tmp/plan.md)
          fi

          # Full review feedback (up to 3KB each)
          REVIEW_TEXT=""
          if [ -f /tmp/codex-plan-review.txt ]; then
            PLAN_REVIEW=$(head -c 3000 /tmp/codex-plan-review.txt)
            [ -n "$PLAN_REVIEW" ] && REVIEW_TEXT="Plan review:
          ${PLAN_REVIEW}"
          fi
          if [ -f /tmp/codex-code-review.txt ]; then
            CODE_REVIEW=$(head -c 3000 /tmp/codex-code-review.txt)
            if [ -n "$CODE_REVIEW" ]; then
              REVIEW_TEXT="${REVIEW_TEXT}

          Code review (${CODE_REVIEW_OK:-unknown}):
          ${CODE_REVIEW}"
            fi
          fi

          # Review fix — what was corrected after review feedback (up to 3KB)
          REVIEW_FIX=""
          if [ -f /tmp/fix-review-output.txt ]; then
            # Extract notify.sh messages from fix-review (what the agent said it fixed)
            FIX_MSGS=$(grep "Sent to Telegram:" /tmp/fix-review-output.txt 2>/dev/null | sed 's/.*Sent to Telegram: //' | head -10)
            # Get the diff of what was actually changed during the fix
            # fix-review runs AFTER the main implementation commit, so diff from implementation commit to HEAD
            FIX_DIFF=$(git log --oneline "$INITIAL_SHA"..HEAD 2>/dev/null | head -5)
            REVIEW_FIX="Fix agent messages: ${FIX_MSGS}
          Commits after review: ${FIX_DIFF}"
          fi

          # Agent-written lessons (the agent writes to this file during execution)
          AGENT_LESSONS=""
          if [ -f /tmp/agent-lessons.md ]; then
            AGENT_LESSONS=$(head -c 4000 /tmp/agent-lessons.md)
          fi

          # Error transcript — build/test failures (up to 3KB)
          ERROR_LOG=""
          for f in /tmp/build-error.log /tmp/test-error.log; do
            if [ -f "$f" ]; then
              ERROR_LOG="${ERROR_LOG}
          $(basename "$f"):
          $(tail -c 1500 "$f")"
            fi
          done

          # Test results — smoke and performance (up to 4KB total)
          TEST_RESULTS=""
          if [ "${SMOKE_OK:-}" = "true" ]; then
            TEST_RESULTS="Smoke tests: PASSED"
          elif [ "${SMOKE_OK:-}" = "false" ]; then
            SMOKE_FAIL=$(grep -E "FAIL|Error|✘|expect|timeout" /tmp/smoke-output.txt 2>/dev/null | head -10)
            TEST_RESULTS="Smoke tests: FAILED
          ${SMOKE_FAIL}"
            # If auto-fix was attempted, include that context
            if [ -f /tmp/fix-smoke-output.txt ]; then
              FIX_RESULT=$(tail -20 /tmp/fix-smoke-output.txt 2>/dev/null)
              TEST_RESULTS="${TEST_RESULTS}

          Auto-fix attempt:
          ${FIX_RESULT}"
            fi
          fi
          if [ "${PERF_OK:-}" = "true" ]; then
            TEST_RESULTS="${TEST_RESULTS}
          Performance tests: PASSED"
          elif [ "${PERF_OK:-}" = "false" ]; then
            PERF_FAIL=$(grep -E "exceeds|below|grew|budget|regression" /tmp/perf-output.txt 2>/dev/null | head -10)
            TEST_RESULTS="${TEST_RESULTS}
          Performance tests: FAILED
          ${PERF_FAIL}"
            if [ -f /tmp/fix-perf-output.txt ]; then
              FIX_RESULT=$(tail -20 /tmp/fix-perf-output.txt 2>/dev/null)
              TEST_RESULTS="${TEST_RESULTS}

          Auto-fix attempt:
          ${FIX_RESULT}"
            fi
          fi

          # Git diff summary (what actually changed, up to 5KB)
          DIFF_STAT=$(git diff --stat "$INITIAL_SHA".."$(git rev-parse HEAD)" 2>/dev/null | tail -20)

          # Agent transcript — extract notify.sh messages from phase outputs (agent's "thinking out loud")
          TRANSCRIPT=""
          for f in /tmp/phase1-output.txt /tmp/phase3-output.txt /tmp/sonnet-output.txt; do
            if [ -f "$f" ]; then
              # Capture lines with "Sent to Telegram" (successful notify.sh calls)
              MSGS=$(grep "Sent to Telegram:" "$f" 2>/dev/null | sed 's/.*Sent to Telegram: //' | head -20)
              [ -n "$MSGS" ] && TRANSCRIPT="${TRANSCRIPT}${MSGS}
          "
            fi
          done

          # --- Build the entry ---
          {
            echo ""
            echo "---"
            echo ""
            echo "## #${ISSUE_NUM} — ${ISSUE_TITLE} (${TODAY})"
            echo "Commit: ${COMMIT_SHORT}"
            echo "Files: ${CHANGED_FILES}"
            echo ""

            if [ -n "$PLAN_TEXT" ]; then
              echo "### Plan"
              echo "$PLAN_TEXT"
              echo ""
            fi

            if [ -n "$REVIEW_TEXT" ]; then
              echo "### Review feedback"
              echo "$REVIEW_TEXT"
              echo ""
            fi

            if [ -n "$REVIEW_FIX" ]; then
              echo "### Corrections after review"
              echo "$REVIEW_FIX"
              echo ""
            fi

            if [ -n "$TRANSCRIPT" ]; then
              echo "### Agent transcript"
              echo "$TRANSCRIPT"
              echo ""
            fi

            if [ -n "$AGENT_LESSONS" ]; then
              echo "### Lessons learned (agent-written)"
              echo "$AGENT_LESSONS"
              echo ""
            fi

            if [ -n "$ERROR_LOG" ]; then
              echo "### Errors encountered"
              echo '```'
              echo "$ERROR_LOG"
              echo '```'
              echo ""
            fi

            if [ -n "$TEST_RESULTS" ]; then
              echo "### Test results"
              echo '```'
              echo "$TEST_RESULTS"
              echo '```'
              echo ""
            fi

            if [ -n "$DIFF_STAT" ]; then
              echo "### Diff summary"
              echo '```'
              echo "$DIFF_STAT"
              echo '```'
              echo ""
            fi
          } >> .claude/branch-context.md

          # Rotate if too large: keep header (first 6 lines) + last ~180KB
          # 180KB ≈ 54K tokens ≈ 27% of Claude's 200K context
          # Each entry ~20-25KB → retains ~8-10 recent tickets (vs 2-3 at old 50KB limit)
          # In IDE, chat history naturally occupies ~80% of context — this is still conservative
          CTX_SIZE=$(wc -c < .claude/branch-context.md)
          if [ "$CTX_SIZE" -gt 200000 ]; then
            echo "Branch context rotating ($CTX_SIZE bytes → ~180KB)..."
            head -6 .claude/branch-context.md > /tmp/ctx-rotated.md
            echo "" >> /tmp/ctx-rotated.md
            echo "[older entries trimmed — $(date +%Y-%m-%d)]" >> /tmp/ctx-rotated.md
            echo "" >> /tmp/ctx-rotated.md
            tail -c 180000 .claude/branch-context.md >> /tmp/ctx-rotated.md
            mv /tmp/ctx-rotated.md .claude/branch-context.md
          fi

          git add .claude/branch-context.md
          git commit -m "chore: update branch context for #${ISSUE_NUM}" || true
          git push origin "$BRANCH" || true

      # ============================================================
      # NOTIFICATIONS
      # ============================================================

      - name: "Notify: all failed"
        if: always() && steps.verify.outputs.pushed != 'true' && steps.dev.outputs.branch != ''
        continue-on-error: true
        run: |
          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"claude_failed\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"${{ steps.dev.outputs.issue_title }}\"}"

      - name: "Notify: changes pushed"
        if: always() && steps.verify.outputs.pushed == 'true' && steps.dev.outputs.branch != ''
        continue-on-error: true
        env:
          ISSUE_NUMBER: ${{ steps.dev.outputs.issue_number }}
          BOT_NOTIFY_URL: ${{ secrets.BOT_WEBHOOK_URL }}
          DEV_BRANCH: ${{ steps.dev.outputs.branch }}
        run: |
          # Report test results in notification
          TEST_STATUS=""
          if [ "$SMOKE_OK" = "true" ]; then
            TEST_STATUS="Smoke: PASSED"
          elif [ "$SMOKE_OK" = "false" ]; then
            TEST_STATUS="Smoke: FAILED (auto-fix attempted)"
          else
            TEST_STATUS="Smoke: skipped"
          fi

          if [ "$PERF_OK" = "true" ]; then
            TEST_STATUS="$TEST_STATUS | Perf: PASSED"
          elif [ "$PERF_OK" = "false" ]; then
            TEST_STATUS="$TEST_STATUS | Perf: REGRESSION (auto-fix attempted)"
          else
            TEST_STATUS="$TEST_STATUS | Perf: skipped"
          fi

          curl -s -X POST "${{ secrets.BOT_WEBHOOK_URL }}/github/notify" \
            -H "Content-Type: application/json" \
            -d "{\"event\":\"merged\",\"branch\":\"${{ steps.dev.outputs.branch }}\",\"issue_number\":\"${{ steps.dev.outputs.issue_number }}\",\"issue_title\":\"${{ steps.dev.outputs.issue_title }}\"}"

      - name: Close issue
        if: always() && steps.verify.outputs.pushed == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const issueNum = context.payload.issue?.number;
            if (issueNum) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNum,
                state: 'closed'
              });
            }
